<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>AI Mobile Particles</title>
    <!-- –í–ê–ñ–ù–û: –ó–∞–ø—Ä–µ—Ç –Ω–∞ –∑—É–º —Å—Ç—Ä–∞–Ω–∏—Ü—ã –ø–∞–ª—å—Ü–∞–º–∏ -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <style>
        :root {
            --primary: #00ff88;
            --glass: rgba(10, 10, 10, 0.85);
            --border: rgba(255, 255, 255, 0.2);
            --success: #00ff00;
            --error: #ff3333;
        }
        body { 
            margin: 0; overflow: hidden; background: #000; 
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
            color: white; user-select: none;
            -webkit-tap-highlight-color: transparent; /* –£–±–∏—Ä–∞–µ—Ç —Å–∏–Ω–∏–π –∫–≤–∞–¥—Ä–∞—Ç –ø—Ä–∏ —Ç–∞–ø–µ */
        }

        /* --- –≠–ö–†–ê–ù –ó–ê–ü–£–°–ö–ê --- */
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle at center, #222 0%, #000 100%);
            z-index: 999; display: flex; flex-direction: column; 
            align-items: center; justify-content: center;
            padding: 20px; text-align: center;
        }
        #start-btn {
            padding: 20px 60px; font-size: 18px; background: var(--primary); color: #000;
            border: none; border-radius: 50px; font-weight: 800; margin-top: 20px;
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.4); text-transform: uppercase;
        }

        /* --- UI PANEL (–ê–¥–∞–ø—Ç–∏–≤–Ω–∞—è) --- */
        #canvas-container { position: absolute; top:0; left:0; width:100%; height:100%; z-index: 1; }
        
        .ui-panel {
            position: absolute; top: 10px; right: 10px; width: 220px;
            background: var(--glass); backdrop-filter: blur(10px);
            padding: 15px; border-radius: 16px; border: 1px solid var(--border);
            z-index: 10; display: none;
        }
        
        /* –ö–ù–û–ü–ö–ò (–ö—Ä—É–ø–Ω–µ–µ –¥–ª—è –ø–∞–ª—å—Ü–µ–≤) */
        button.toggle-btn {
            background: rgba(255,255,255,0.1); border: 2px solid transparent;
            color: #ccc; padding: 12px; border-radius: 8px; 
            font-size: 12px; font-weight: bold; width: 100%; margin-bottom: 8px;
        }
        button.toggle-btn.active { background: rgba(255,255,255,0.2); color: #fff; }
        
        /* –°—Ç–∞—Ç—É—Å—ã –∫–Ω–æ–ø–∫–∏ –≤–∏–¥–µ–æ */
        #btn-cam.status-lost { border-color: var(--error); }
        #btn-cam.status-ok { border-color: var(--success); color: var(--success); box-shadow: 0 0 10px rgba(0,255,0,0.3); }

        .shape-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 15px; }
        button.shape-btn {
            background: rgba(255,255,255,0.1); border: 1px solid var(--border);
            color: #ccc; padding: 12px; border-radius: 8px; font-size: 12px;
        }
        button.shape-btn.active { background: var(--primary); color: #000; font-weight: bold; }
        
        /* –í–ò–î–ï–û –ü–†–ï–í–¨–Æ (–ú–∞–ª–µ–Ω—å–∫–æ–µ –≤ —É–≥–ª—É) */
        #webcam-preview {
            position: absolute; bottom: 20px; left: 20px; width: 100px; height: 133px; /* 3:4 aspect ratio for mobile portrait */
            background: #000; border: 1px solid var(--border); z-index: 10;
            border-radius: 10px; transform: scaleX(-1); object-fit: cover;
            opacity: 0; pointer-events: none; transition: opacity 0.3s;
        }
        #webcam-preview.visible { opacity: 0.7; pointer-events: auto; }

        /* FULLSCREEN HINT */
        #fs-hint {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            font-size: 10px; color: #666; pointer-events: none;
        }

        /* Clean Mode */
        body.clean-mode .ui-panel, body.clean-mode #webcam-preview { opacity: 0 !important; pointer-events: none; }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>
<body>

    <div id="start-screen">
        <h1 style="font-size: 24px;">AI MOBILE</h1>
        <div style="font-size: 12px; color: #aaa; margin-bottom: 10px;">–í–∫–ª—é—á–∏—Ç–µ —Ñ—Ä–æ–Ω—Ç–∞–ª—å–Ω—É—é –∫–∞–º–µ—Ä—É</div>
        <button id="start-btn" onclick="startSystem()">–°–¢–ê–†–¢</button>
    </div>

    <div id="canvas-container"></div>
    
    <!-- playsinline –≤–∞–∂–Ω–æ –¥–ª—è iPhone/Android —á—Ç–æ–±—ã –≤–∏–¥–µ–æ –Ω–µ –æ—Ç–∫—Ä—ã–≤–∞–ª–æ—Å—å –Ω–∞ –≤–µ—Å—å —ç–∫—Ä–∞–Ω -->
    <video id="webcam-preview" class="visible" playsinline autoplay muted></video>

    <div class="ui-panel" id="ui-panel">
        <button id="btn-full" class="toggle-btn" onclick="toggleFullscreen()">‚õ∂ –ù–∞ –≤–µ—Å—å —ç–∫—Ä–∞–Ω</button>
        
        <div style="display: flex; gap: 8px; margin-bottom: 15px;">
            <button id="btn-mic" class="toggle-btn active" style="margin:0" onclick="toggleMic()">üé§</button>
            <button id="btn-cam" class="toggle-btn active status-lost" style="margin:0" onclick="toggleCam()">üì∑</button>
        </div>

        <div class="shape-grid">
            <button class="shape-btn active" onclick="setShape('sphere')">–°—Ñ–µ—Ä–∞</button>
            <button class="shape-btn" onclick="setShape('heart')">–°–µ—Ä–¥—Ü–µ</button>
            <button class="shape-btn" onclick="setShape('bear')">–ú–∏—à–∫–∞</button>
            <button class="shape-btn" onclick="setShape('dna')">–î–ù–ö</button>
        </div>
        
        <input type="color" id="colorPicker" value="#00ff88" style="width:100%; height:40px; border:none; background:none;">
    </div>
    
    <div id="fs-hint">–î–≤–æ–π–Ω–æ–π —Ç–∞–ø: —Å–∫—Ä—ã—Ç—å –º–µ–Ω—é</div>

    <script>
        // --- MOBILE CONFIG ---
        // –°–Ω–∏–∂–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —á–∞—Å—Ç–∏—Ü –¥–ª—è —Ç–µ–ª–µ—Ñ–æ–Ω–æ–≤
        const CONFIG = { particleCount: 12000, baseSize: 0.12, smooth: 0.1 };
        const STATE = {
            scale: 1, audioPulse: 0, rotX: 0, rotY: 0, tilt: 0,
            baseColor: new THREE.Color(0x00ff88)
        };
        const TARGET = { scale: 1, x: 0, y: 0, tilt: 0, detected: false };
        
        let scene, camera, renderer, particles;
        let audioCtx, analyser, dataArray;
        let isAudioAllowed = false;

        // --- FULLSCREEN ---
        function toggleFullscreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen().catch(e => console.log(e));
            } else {
                if (document.exitFullscreen) document.exitFullscreen();
            }
        }
        // Double tap handler
        let lastTap = 0;
        document.addEventListener('touchend', function(e) {
            const currentTime = new Date().getTime();
            const tapLength = currentTime - lastTap;
            if (tapLength < 500 && tapLength > 0) {
                document.body.classList.toggle('clean-mode');
                e.preventDefault();
            }
            lastTap = currentTime;
        });

        // --- START ---
        async function startSystem() {
            const btn = document.getElementById('start-btn');
            btn.innerText = "–ó–ê–ì–†–£–ó–ö–ê...";
            
            initThree();

            // Init Audio
            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                audioCtx = new AudioContext();
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                analyser = audioCtx.createAnalyser();
                analyser.fftSize = 256;
                const source = audioCtx.createMediaStreamSource(stream);
                source.connect(analyser);
                dataArray = new Uint8Array(analyser.frequencyBinCount);
                isAudioAllowed = true;
            } catch(e) {
                console.warn("Audio fail");
                document.getElementById('btn-mic').classList.replace('active', 'off');
                document.getElementById('btn-mic').style.opacity = '0.3';
            }

            // Init Camera Manually for Mobile (Best practice)
            await initCameraAndMediaPipe();

            document.getElementById('start-screen').style.display = 'none';
            document.getElementById('ui-panel').style.display = 'block';
        }

        // --- CAMERA & MEDIAPIPE ---
        async function initCameraAndMediaPipe() {
            const video = document.getElementById('webcam-preview');
            const camBtn = document.getElementById('btn-cam');

            // 1. –†—É—á–Ω–æ–π –∑–∞–ø—É—Å–∫ –∫–∞–º–µ—Ä—ã —Å facingMode: 'user' (–§—Ä–æ–Ω—Ç–∞–ª–∫–∞)
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: {
                        facingMode: 'user', // –§—Ä–æ–Ω—Ç–∞–ª—å–Ω–∞—è –∫–∞–º–µ—Ä–∞
                        width: { ideal: 640 },
                        height: { ideal: 480 }
                    }
                });
                video.srcObject = stream;
                await new Promise(resolve => video.onloadedmetadata = resolve);
                video.play();
            } catch (e) {
                alert("–û—à–∏–±–∫–∞ –∫–∞–º–µ—Ä—ã! –ü—Ä–æ–≤–µ—Ä—å—Ç–µ, —á—Ç–æ —Å–∞–π—Ç –æ—Ç–∫—Ä—ã—Ç —á–µ—Ä–µ–∑ HTTPS.");
                return;
            }

            // 2. MediaPipe Hands
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            
            hands.setOptions({
                maxNumHands: 1,
                modelComplexity: 1, // 0 - –±—ã—Å—Ç—Ä–µ–µ, 1 - —Ç–æ—á–Ω–µ–µ. –î–ª—è —Å–æ–≤—Ä–µ–º–µ–Ω–Ω—ã—Ö —Ç–µ–ª–µ—Ñ–æ–Ω–æ–≤ 1 –æ–∫.
                minDetectionConfidence: 0.5,
                minTrackingConfidence: 0.5
            });

            hands.onResults((results) => {
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    TARGET.detected = true;
                    camBtn.classList.remove('status-lost');
                    camBtn.classList.add('status-ok');

                    const lm = results.multiHandLandmarks[0];
                    const dist = Math.hypot(lm[4].x-lm[8].x, lm[4].y-lm[8].y);
                    TARGET.scale = Math.max(0.5, Math.min(3.0 - (dist*10), 3.0));
                    
                    // Center palm logic
                    TARGET.x = ((lm[9].x)-0.5)*2; 
                    TARGET.y = ((lm[9].y)-0.5)*2;
                    
                    // Tilt
                    const dx = lm[9].x - lm[0].x;
                    const dy = lm[9].y - lm[0].y;
                    TARGET.tilt = Math.atan2(dy, dx) + Math.PI/2;
                } else {
                    TARGET.detected = false;
                    camBtn.classList.remove('status-ok');
                    camBtn.classList.add('status-lost');
                }
            });

            // –¶–∏–∫–ª –æ—Ç–ø—Ä–∞–≤–∫–∏ –∫–∞–¥—Ä–æ–≤ –≤ MediaPipe
            async function detectionLoop() {
                if (video.readyState === 4) {
                    await hands.send({image: video});
                }
                requestAnimationFrame(detectionLoop);
            }
            detectionLoop();
        }

        // --- THREE.JS ---
        let targetPositions = new Float32Array(CONFIG.particleCount * 3);

        function initThree() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.02);
            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            camera.position.z = 9; // –ß—É—Ç—å –¥–∞–ª—å—à–µ –¥–ª—è –º–æ–±–∏–ª—å–Ω—ã—Ö —ç–∫—Ä–∞–Ω–æ–≤
            
            renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true }); // Antialias off –¥–ª—è FPS
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('canvas-container').appendChild(renderer.domElement);

            // Texture
            const cvs = document.createElement('canvas'); cvs.width=32; cvs.height=32;
            const ctx = cvs.getContext('2d');
            const grad = ctx.createRadialGradient(16,16,0,16,16,16);
            grad.addColorStop(0,'white'); grad.addColorStop(1,'transparent');
            ctx.fillStyle = grad; ctx.fillRect(0,0,32,32);
            const tex = new THREE.Texture(cvs); tex.needsUpdate = true;

            const geo = new THREE.BufferGeometry();
            const pos = new Float32Array(CONFIG.particleCount * 3);
            for(let i=0; i<CONFIG.particleCount*3; i++) pos[i] = (Math.random()-0.5)*20;
            geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));

            const mat = new THREE.PointsMaterial({
                size: CONFIG.baseSize, map: tex, transparent: true, opacity: 0.8,
                blending: THREE.AdditiveBlending, depthWrite: false, color: STATE.baseColor
            });

            particles = new THREE.Points(geo, mat);
            scene.add(particles);
            setShape('sphere');
            animate();
        }

        function lerp(s, e, a) { return (1-a)*s + a*e; }

        function animate() {
            requestAnimationFrame(animate);

            // Audio
            if (isAudioAllowed && audioCtx.state === 'running' && analyser) {
                analyser.getByteFrequencyData(dataArray);
                let sum = 0; for(let i=0; i<8; i++) sum+=dataArray[i];
                STATE.audioPulse = lerp(STATE.audioPulse, (sum/8)/255, 0.2);
                
                if(STATE.audioPulse > 0.35) {
                    const h = STATE.baseColor.getHSL({});
                    particles.material.color.setHSL(h.h, h.s, Math.min(1, 0.5 + STATE.audioPulse));
                } else {
                    particles.material.color.lerp(STATE.baseColor, 0.1);
                }
            }

            // Logic
            if (TARGET.detected) {
                STATE.scale = lerp(STATE.scale, TARGET.scale, CONFIG.smooth);
                const vx = (Math.abs(TARGET.x)>0.1) ? TARGET.x*0.05 : 0;
                const vy = (Math.abs(TARGET.y)>0.1) ? TARGET.y*0.05 : 0;
                STATE.rotY = lerp(STATE.rotY, vx, CONFIG.smooth);
                STATE.rotX = lerp(STATE.rotX, vy, CONFIG.smooth);
                STATE.tilt = lerp(STATE.tilt, -TARGET.tilt, CONFIG.smooth);
            } else {
                STATE.scale = lerp(STATE.scale, 1, 0.05);
                STATE.rotY = lerp(STATE.rotY, 0.002, 0.05);
                STATE.rotX = lerp(STATE.rotX, 0, 0.05);
                STATE.tilt = lerp(STATE.tilt, 0, 0.05);
            }

            const totalScale = STATE.scale + (STATE.audioPulse * 0.5);
            particles.scale.set(totalScale, totalScale, totalScale);
            particles.rotation.y += STATE.rotY;
            particles.rotation.x += STATE.rotX;
            particles.rotation.z = STATE.tilt;

            const p = particles.geometry.attributes.position.array;
            for(let i=0; i<CONFIG.particleCount*3; i++) p[i] += (targetPositions[i]-p[i])*0.08;
            particles.geometry.attributes.position.needsUpdate = true;

            renderer.render(scene, camera);
        }

        // --- UTILS & SHAPES ---
        function getSpherePoint(cx, cy, cz, r) {
            const u = Math.random(), v = Math.random();
            const theta = 2 * Math.PI * u;
            const phi = Math.acos(2 * v - 1);
            return {
                x: cx + r * Math.sin(phi) * Math.cos(theta),
                y: cy + r * Math.sin(phi) * Math.sin(theta),
                z: cz + r * Math.cos(phi)
            };
        }

        window.setShape = function(s) {
            for(let i=0; i<CONFIG.particleCount; i++) {
                let x,y,z;
                if (s === 'sphere') {
                    const p = getSpherePoint(0,0,0, 3.5); x=p.x; y=p.y; z=p.z;
                } else if (s === 'bear') {
                    const r = Math.random();
                    let p;
                    if(r<0.35) p = getSpherePoint(0,-1,0,1.6);
                    else if(r<0.6) p = getSpherePoint(0,1.3,0,1.1);
                    else if(r<0.7) p = getSpherePoint(Math.random()>0.5?0.9:-0.9,-2.6,0,0.6);
                    else if(r<0.8) p = getSpherePoint(Math.random()>0.5?1.6:-1.6,-0.2,0.2,0.55);
                    else if(r<0.9) p = getSpherePoint(Math.random()>0.5?0.85:-0.85,2.1,0,0.35);
                    else p = getSpherePoint(0,1.2,0.9,0.35);
                    x=p.x; y=p.y; z=p.z;
                } else if (s === 'heart') {
                   const t=Math.random()*6.28, p=Math.random()*3.14;
                   x=16*Math.pow(Math.sin(t),3); y=13*Math.cos(t)-5*Math.cos(2*t)-2*Math.cos(3*t)-Math.cos(4*t); z=5*Math.cos(p)*Math.sin(t);
                   x*=0.18; y*=0.18; z*=0.18;
                } else if (s === 'dna') {
                     const ang=(Math.random()*3*6.28)+(i%2*3.14); 
                     x=Math.cos(ang)*2+(Math.random()-0.5); y=(Math.random()-0.5)*10; z=Math.sin(ang)*2+(Math.random()-0.5);
                }
                targetPositions[i*3]=x; targetPositions[i*3+1]=y; targetPositions[i*3+2]=z;
            }
            document.querySelectorAll('.shape-btn').forEach(b => b.classList.remove('active'));
            if(event) event.target.classList.add('active');
        };

        window.toggleMic = function() {
            if(!audioCtx) return;
            if(audioCtx.state==='running') { audioCtx.suspend(); document.getElementById('btn-mic').classList.replace('active','off'); STATE.audioPulse=0; }
            else { audioCtx.resume(); document.getElementById('btn-mic').classList.replace('off','active'); }
        }
        window.toggleCam = function() {
            const vid = document.getElementById('webcam-preview');
            vid.classList.toggle('visible');
            document.getElementById('btn-cam').classList.toggle('off');
        }

        document.getElementById('colorPicker').addEventListener('input', (e) => STATE.baseColor.set(e.target.value));
        window.addEventListener('resize', () => {camera.aspect=window.innerWidth/window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight);});
    </script>
</body>
</html>